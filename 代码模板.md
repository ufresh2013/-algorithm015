### 代码模板
#### 1. 二叉树
- 节点定义
```js
function TreeNode(val) {
 this.val = val;
 this.left = null;
 this.right = null;
}
```

- 前序遍历
```js
const preorder = node => {
  if (!node) return
  path.push(node.val)
  preorder(node.left)
  preorder(node.right)
}
```

- 中序遍历
```js
const inorder = node => {
  if (!node) return
  inorder(node.left)
  path.push(node.val)
  inorder(node.right)
}
```

- 后序遍历
```js
const backorder = node => {
  if (!node) return
  backorder(node.left)
  backorder(node.right)
  path.push(node.val)
}
```

### N叉树


### 递归
```js
const recursion = (level, params) {
  // recursion terminator
  if (level > MAX_LEVEL) {
    process_result
    return
  }

  // process current level
  process(level, params)
  // drill down
  recursion(level + 1, parms)
  // clean current level status if need
}
```

### 分治
```js
const divide_conquer = (problem, params) => {
  if (problem == null) {
    process_result
    return
  }

  // process current problem
  subproblem = split_problem(problem, data)
  sub_result1 = divide_conquer(subproblem[0], p1)
}
```

### DFS 深度优先搜索
```js
// 递归写法
const visited = new Set()
const dfs = node => {
  if (visited.has(node)) return
  visited.add(node)
  dfs(node.left)
  dfs(node.right)
}

// 非递归写法
const dfs = (node) => {
  if (!node) return
  const visited = []
  const stack = node
  while (stack.length > 0) {
    const node = stack.pop()
    visited.push(node)
    process(node)

    const nodes = generate_related_nodes(node)
    stack.push(nodes)
  } 
}
```


### BFS 广度优先搜索
```js
const bfs = (root) => {
  const result = []
  const queue = [root]
  while (queue.length > 0) {
    const level = []
    const n = queue.length
    for (let i = 0; i < n; i++) {
      const node = queue.pop()
      level.push(node.val)
      if (node.left) queue.unshift(node.left)
      if (node.right) queue.unshift(node.right)
    }
    result.push(level)
  }
  return result
}
```

### 二分查找
```js
const binarySearch = (array, target) => {
  let left = 0; right = array.length - 1
  while(left <= right) {
    let mid = (left + right) >> 1
    if (array[mid] === target) {
      return mid
    } else if (array[mid] < target) {
      left = mid + 1
    } else {
      right = mid - 1
    }
  }
  return -1
}
```

### 并查集
```js

```