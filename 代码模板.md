### 代码模板
#### 1. 二叉树
- 节点定义
```js
function TreeNode(val) {
 this.val = val;
 this.left = null;
 this.right = null;
}
```

- 前序遍历
```js
const preorder = node => {
  if (!node) return
  path.push(node.val)
  preorder(node.left)
  preorder(node.right)
}
```

- 中序遍历
```js
const inorder = node => {
  if (!node) return
  inorder(node.left)
  path.push(node.val)
  inorder(node.right)
}
```

- 后序遍历
```js
const backorder = node => {
  if (!node) return
  backorder(node.left)
  backorder(node.right)
  path.push(node.val)
}
```

### N叉树


### 递归
```js
const recursion = (level, params) {
  // recursion terminator
  if (level > MAX_LEVEL) {
    process_result
    return
  }

  // process current level
  process(level, params)
  // drill down
  recursion(level + 1, parms)
  // clean current level status if need
}
```

### 分治
```js
const divide_conquer = (problem, params) => {
  if (problem == null) {
    process_result
    return
  }

  // process current problem
  subproblem = split_problem(problem, data)
  sub_result1 = divide_conquer(subproblem[0], p1)
}
```

### DFS
```js
const visited = new Set()
const dfs = node => {
  if (visited.has(node)) return
  visited.add(node)
  dfs(node.left)
  dfs(node.right)
}
```


### BFS
```js
const bfs = (root) => {
  let result = []
  let queue = [root]
  while (queue.length > 0) {
    
  }
}
```

### 二分查找
```js
const binarySearch = (array, target) => {
  let left = 0; right = array.length - 1
  while(left <= right) {
    let mid = (left + right) >> 1
    if (array[mid] === target) {
      return mid
    } else if (array[mid] < target) {
      left = mid + 1
    } else {
      right = mid - 1
    }
  }
  return -1
}
```