### 二叉树

为什么有树这个数据结构？假设递归求斐波那契数列`f(n) = f(n-1) + f(n-2)`，如果把整个计算过程展开，你会发现这是一棵树。像 html，dom 节点展开后是一棵树。
如果树是无序的，查找元素是`O(n)`
如果树是有序的（二叉搜索树），查找元素是`O(logn)`，类似于二分查找。假设一棵树所有结点都只有右节点，它就退化成链表，查询时间复杂度退化为`O(n)`

- 二叉搜索树

  - 左子树的所有节点小于根节点
  - 右子树的所有节点大于根节点
  - 左右子树也是二叉搜索树

- 二叉树的遍历方式

  - 前序遍历：根节点 -> 左子树 -> 右子树
  - 中序遍历：左子树 -> 根节点 -> 右子树
  - 后序遍历：左子树 -> 右子树 -> 根节点

#### 1. 节点定义

```js
function TreeNode(val) {
  this.val = val;
  this.left = null;
  this.right = null;
}
```

#### 2. 二叉树的遍历

树的解题方法一般都是递归，因为每个节点的结构相同，当你想访问左节点时，最好的方式是对左节点再调用一遍函数。

- 前序遍历

```js
const preorder = (node) => {
  if (!node) return;
  path.push(node.val);
  preorder(node.left);
  preorder(node.right);
};
```

- 中序遍历

```js
const inorder = (node) => {
  if (!node) return;
  inorder(node.left);
  path.push(node.val);
  inorder(node.right);
};
```

- 后序遍历

```js
const backorder = (node) => {
  if (!node) return;
  backorder(node.left);
  backorder(node.right);
  path.push(node.val);
};
```

### 3. 递归与树

在函数体里调用函数本身，称为递归。把递归的全过程剥开，你会发现它是一个树结构。

```js
// 斐波那契
function f(n) {
  if (n === 0 || n === 1) return n;
  return f(n - 1) + f(n - 2);
}

// 把它剥开，发现是一个树结构
f(6);
6 * f(5);
6 * 5 * f(4);
6 * 5 * 4 * f(3);
6 * 5 * 4 * 3 * f(2);
6 * 5 * 4 * 3 * 2 * f(1);
6 * 5 * 4 * 3 * 2 * 1;
```
