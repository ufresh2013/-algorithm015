### 1. BFS 广度优先搜索

搜索顺序：不用递归，而是用队列，一层一层向下扩展, 像水纹一样。常用在求最短路径的问题上。
常见题目：102-二叉树的层次遍历

```js
const bfs = (root) => {
  const result = [];
  const queue = [root];
  while (queue.length > 0) {
    const level = [];
    const n = queue.length;
    for (let i = 0; i < n; i++) {
      const node = queue.pop();
      level.push(node.val);
      if (node.left) queue.unshift(node.left);
      if (node.right) queue.unshift(node.right);
    }
    result.push(level);
  }
  return result;
};
```

### 4. 分治

```js
const divide_conquer = (problem, params) => {
  if (problem == null) {
    process_result;
    return;
  }

  // process current problem
  subproblem = split_problem(problem, data);
  sub_result1 = divide_conquer(subproblem[0], p1);
};
```

### 5. 启发式搜索 A\* search

启发式函数：h(n), 用来评价哪些节点最有希望会是我们要找的节点。常用于推荐算法，搜索顺序不是广度优先，也不是深度优先，而是优先级优先。

```js
function AstartSearch (graph, start, end) {
  const pq = collection.priority_queue() // 按优先级排序 -> 估价函数
  pq.append([start])
  visited.add(start)

  while (pq.length > 0) {
    node = pq.pop() // can we add more intelligence here?
    visited.add(node)

    process(node)
    unvisited = [node in nodes if node not in visited]
    pq.push(unvisited)
  }
}
```
